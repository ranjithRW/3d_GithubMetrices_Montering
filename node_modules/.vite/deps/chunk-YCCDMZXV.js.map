{
  "version": 3,
  "sources": ["../../@theatre/dataverse/src/index.ts", "../../node_modules/lodash-es/isArray.js", "../../node_modules/lodash-es/_freeGlobal.js", "../../node_modules/lodash-es/_root.js", "../../node_modules/lodash-es/_Symbol.js", "../../node_modules/lodash-es/_getRawTag.js", "../../node_modules/lodash-es/_objectToString.js", "../../node_modules/lodash-es/_baseGetTag.js", "../../node_modules/lodash-es/isObjectLike.js", "../../node_modules/lodash-es/isSymbol.js", "../../node_modules/lodash-es/_isKey.js", "../../node_modules/lodash-es/isObject.js", "../../node_modules/lodash-es/isFunction.js", "../../node_modules/lodash-es/_coreJsData.js", "../../node_modules/lodash-es/_isMasked.js", "../../node_modules/lodash-es/_toSource.js", "../../node_modules/lodash-es/_baseIsNative.js", "../../node_modules/lodash-es/_getValue.js", "../../node_modules/lodash-es/_getNative.js", "../../node_modules/lodash-es/_nativeCreate.js", "../../node_modules/lodash-es/_hashClear.js", "../../node_modules/lodash-es/_hashDelete.js", "../../node_modules/lodash-es/_hashGet.js", "../../node_modules/lodash-es/_hashHas.js", "../../node_modules/lodash-es/_hashSet.js", "../../node_modules/lodash-es/_Hash.js", "../../node_modules/lodash-es/_listCacheClear.js", "../../node_modules/lodash-es/eq.js", "../../node_modules/lodash-es/_assocIndexOf.js", "../../node_modules/lodash-es/_listCacheDelete.js", "../../node_modules/lodash-es/_listCacheGet.js", "../../node_modules/lodash-es/_listCacheHas.js", "../../node_modules/lodash-es/_listCacheSet.js", "../../node_modules/lodash-es/_ListCache.js", "../../node_modules/lodash-es/_Map.js", "../../node_modules/lodash-es/_mapCacheClear.js", "../../node_modules/lodash-es/_isKeyable.js", "../../node_modules/lodash-es/_getMapData.js", "../../node_modules/lodash-es/_mapCacheDelete.js", "../../node_modules/lodash-es/_mapCacheGet.js", "../../node_modules/lodash-es/_mapCacheHas.js", "../../node_modules/lodash-es/_mapCacheSet.js", "../../node_modules/lodash-es/_MapCache.js", "../../node_modules/lodash-es/memoize.js", "../../node_modules/lodash-es/_memoizeCapped.js", "../../node_modules/lodash-es/_stringToPath.js", "../../node_modules/lodash-es/_arrayMap.js", "../../node_modules/lodash-es/_baseToString.js", "../../node_modules/lodash-es/toString.js", "../../node_modules/lodash-es/_castPath.js", "../../node_modules/lodash-es/_toKey.js", "../../node_modules/lodash-es/_baseGet.js", "../../node_modules/lodash-es/get.js", "../../node_modules/lodash-es/_overArg.js", "../../node_modules/lodash-es/_getPrototype.js", "../../node_modules/lodash-es/isPlainObject.js", "../../node_modules/lodash-es/last.js", "../../@theatre/dataverse/src/utils/Tappable.ts", "../../@theatre/dataverse/src/utils/Emitter.ts", "../../@theatre/dataverse/src/derivations/DerivationEmitter.ts", "../../@theatre/dataverse/src/derivations/DerivationValuelessEmitter.ts", "../../@theatre/dataverse/src/derivations/IDerivation.ts", "../../@theatre/dataverse/src/derivations/flatMap.ts", "../../@theatre/dataverse/src/derivations/map.ts", "../../@theatre/dataverse/src/utils/Stack.ts", "../../@theatre/dataverse/src/derivations/prism/discoveryMechanism.ts", "../../@theatre/dataverse/src/derivations/AbstractDerivation.ts", "../../@theatre/dataverse/src/derivations/DerivationFromSource.ts", "../../@theatre/dataverse/src/pointer.ts", "../../@theatre/dataverse/src/utils/updateDeep.ts", "../../@theatre/dataverse/src/Atom.ts", "../../@theatre/dataverse/src/Box.ts", "../../@theatre/dataverse/src/derivations/ConstantDerivation.ts", "../../@theatre/dataverse/src/derivations/iterateAndCountTicks.ts", "../../@theatre/dataverse/src/Ticker.ts", "../../@theatre/dataverse/src/derivations/iterateOver.ts", "../../@theatre/dataverse/src/derivations/prism/prism.ts", "../../@theatre/dataverse/src/PointerProxy.ts"],
  "sourcesContent": ["/**\n * The animation-optimized FRP library powering the internals of Theatre.js.\n *\n * @packageDocumentation\n */\n\nexport type {IdentityDerivationProvider} from './Atom'\nexport {default as Atom, val, valueDerivation} from './Atom'\nexport {default as Box} from './Box'\nexport type {IBox} from './Box'\nexport {default as AbstractDerivation} from './derivations/AbstractDerivation'\nexport {default as ConstantDerivation} from './derivations/ConstantDerivation'\nexport {default as DerivationFromSource} from './derivations/DerivationFromSource'\nexport {isDerivation} from './derivations/IDerivation'\nexport type {IDerivation} from './derivations/IDerivation'\nexport {default as iterateAndCountTicks} from './derivations/iterateAndCountTicks'\nexport {default as iterateOver} from './derivations/iterateOver'\nexport {default as prism} from './derivations/prism/prism'\nexport {default as pointer, getPointerParts, isPointer} from './pointer'\nexport type {Pointer, PointerType} from './pointer'\nexport {default as Ticker} from './Ticker'\nexport {default as PointerProxy} from './PointerProxy'\n", "/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nexport default isArray;\n", "/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nexport default freeGlobal;\n", "import freeGlobal from './_freeGlobal.js';\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nexport default root;\n", "import root from './_root.js';\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nexport default Symbol;\n", "import Symbol from './_Symbol.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nexport default getRawTag;\n", "/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nexport default objectToString;\n", "import Symbol from './_Symbol.js';\nimport getRawTag from './_getRawTag.js';\nimport objectToString from './_objectToString.js';\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nexport default baseGetTag;\n", "/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nexport default isObjectLike;\n", "import baseGetTag from './_baseGetTag.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nexport default isSymbol;\n", "import isArray from './isArray.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nexport default isKey;\n", "/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nexport default isObject;\n", "import baseGetTag from './_baseGetTag.js';\nimport isObject from './isObject.js';\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nexport default isFunction;\n", "import root from './_root.js';\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nexport default coreJsData;\n", "import coreJsData from './_coreJsData.js';\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nexport default isMasked;\n", "/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nexport default toSource;\n", "import isFunction from './isFunction.js';\nimport isMasked from './_isMasked.js';\nimport isObject from './isObject.js';\nimport toSource from './_toSource.js';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nexport default baseIsNative;\n", "/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nexport default getValue;\n", "import baseIsNative from './_baseIsNative.js';\nimport getValue from './_getValue.js';\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nexport default getNative;\n", "import getNative from './_getNative.js';\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nexport default nativeCreate;\n", "import nativeCreate from './_nativeCreate.js';\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nexport default hashClear;\n", "/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nexport default hashDelete;\n", "import nativeCreate from './_nativeCreate.js';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nexport default hashGet;\n", "import nativeCreate from './_nativeCreate.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nexport default hashHas;\n", "import nativeCreate from './_nativeCreate.js';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nexport default hashSet;\n", "import hashClear from './_hashClear.js';\nimport hashDelete from './_hashDelete.js';\nimport hashGet from './_hashGet.js';\nimport hashHas from './_hashHas.js';\nimport hashSet from './_hashSet.js';\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nexport default Hash;\n", "/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nexport default listCacheClear;\n", "/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nexport default eq;\n", "import eq from './eq.js';\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nexport default assocIndexOf;\n", "import assocIndexOf from './_assocIndexOf.js';\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nexport default listCacheDelete;\n", "import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nexport default listCacheGet;\n", "import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nexport default listCacheHas;\n", "import assocIndexOf from './_assocIndexOf.js';\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nexport default listCacheSet;\n", "import listCacheClear from './_listCacheClear.js';\nimport listCacheDelete from './_listCacheDelete.js';\nimport listCacheGet from './_listCacheGet.js';\nimport listCacheHas from './_listCacheHas.js';\nimport listCacheSet from './_listCacheSet.js';\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nexport default ListCache;\n", "import getNative from './_getNative.js';\nimport root from './_root.js';\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nexport default Map;\n", "import Hash from './_Hash.js';\nimport ListCache from './_ListCache.js';\nimport Map from './_Map.js';\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nexport default mapCacheClear;\n", "/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nexport default isKeyable;\n", "import isKeyable from './_isKeyable.js';\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nexport default getMapData;\n", "import getMapData from './_getMapData.js';\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nexport default mapCacheDelete;\n", "import getMapData from './_getMapData.js';\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nexport default mapCacheGet;\n", "import getMapData from './_getMapData.js';\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nexport default mapCacheHas;\n", "import getMapData from './_getMapData.js';\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nexport default mapCacheSet;\n", "import mapCacheClear from './_mapCacheClear.js';\nimport mapCacheDelete from './_mapCacheDelete.js';\nimport mapCacheGet from './_mapCacheGet.js';\nimport mapCacheHas from './_mapCacheHas.js';\nimport mapCacheSet from './_mapCacheSet.js';\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nexport default MapCache;\n", "import MapCache from './_MapCache.js';\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nexport default memoize;\n", "import memoize from './memoize.js';\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nexport default memoizeCapped;\n", "import memoizeCapped from './_memoizeCapped.js';\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nexport default stringToPath;\n", "/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nexport default arrayMap;\n", "import Symbol from './_Symbol.js';\nimport arrayMap from './_arrayMap.js';\nimport isArray from './isArray.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nexport default baseToString;\n", "import baseToString from './_baseToString.js';\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nexport default toString;\n", "import isArray from './isArray.js';\nimport isKey from './_isKey.js';\nimport stringToPath from './_stringToPath.js';\nimport toString from './toString.js';\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nexport default castPath;\n", "import isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nexport default toKey;\n", "import castPath from './_castPath.js';\nimport toKey from './_toKey.js';\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nexport default baseGet;\n", "import baseGet from './_baseGet.js';\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nexport default get;\n", "/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nexport default overArg;\n", "import overArg from './_overArg.js';\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nexport default getPrototype;\n", "import baseGetTag from './_baseGetTag.js';\nimport getPrototype from './_getPrototype.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nexport default isPlainObject;\n", "/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\n\nexport default last;\n", "type Untap = () => void\ntype UntapFromSource = () => void\n\ninterface IProps<V> {\n  tapToSource: (cb: (payload: V) => void) => UntapFromSource\n}\n\ntype Listener<V> = ((v: V) => void) | (() => void)\n\n/**\n * Represents a data-source that can be tapped (subscribed to).\n */\nexport default class Tappable<V> {\n  private _props: IProps<V>\n  private _tappers: Map<number, {bivarianceHack(v: V): void}['bivarianceHack']>\n  private _untapFromSource: null | UntapFromSource\n  private _lastTapperId: number\n  private _untapFromSourceTimeout: null | NodeJS.Timer = null\n\n  constructor(props: IProps<V>) {\n    this._lastTapperId = 0\n    this._untapFromSource = null\n    this._props = props\n    this._tappers = new Map()\n  }\n\n  private _check() {\n    if (this._untapFromSource) {\n      if (this._tappers.size === 0) {\n        this._scheduleToUntapFromSource()\n        /*\n         * this._untapFromSource()\n         * this._untapFromSource = null\n         */\n      }\n    } else {\n      if (this._tappers.size !== 0) {\n        this._untapFromSource = this._props.tapToSource(this._cb)\n      }\n    }\n  }\n\n  private _scheduleToUntapFromSource() {\n    if (this._untapFromSourceTimeout !== null) return\n    this._untapFromSourceTimeout = setTimeout(() => {\n      this._untapFromSourceTimeout = null\n      if (this._tappers.size === 0) {\n        this._untapFromSource!()\n\n        this._untapFromSource = null\n      }\n    }, 0)\n  }\n\n  private _cb: any = (arg: any): void => {\n    for (const cb of this._tappers.values()) {\n      cb(arg)\n    }\n  }\n\n  /**\n   * Tap (subscribe to) the data source.\n   *\n   * @param cb - The callback to be called on a change.\n   */\n  tap(cb: Listener<V>): Untap {\n    const tapperId = this._lastTapperId++\n    this._tappers.set(tapperId, cb)\n    this._check()\n    return () => {\n      this._removeTapperById(tapperId)\n    }\n  }\n\n  /*\n   * tapImmediate(cb: Listener<V>): Untap {\n   *   const ret = this.tap(cb)\n   *   return ret\n   * }\n   */\n\n  private _removeTapperById(id: number) {\n    this._tappers.delete(id)\n    this._check()\n  }\n\n  // /**\n  //  * @deprecated\n  //  */\n  // map<T>(transform: {bivarianceHack(v: V): T}['bivarianceHack']): Tappable<T> {\n  //   return new Tappable({\n  //     tapToSource: (cb: (v: T) => void) => {\n  //       return this.tap((v: $IntentionalAny) => {\n  //         return cb(transform(v))\n  //       })\n  //     },\n  //   })\n  // }\n}\n", "import Tappable from './Tappable'\n\ntype Tapper<V> = (v: V) => void\ntype Untap = () => void\n\n/**\n * An event emitter. Emit events that others can tap (subscribe to).\n */\nexport default class Emitter<V> {\n  private _tappers: Map<any, (v: V) => void>\n  private _lastTapperId: number\n  private _onNumberOfTappersChangeListener: undefined | ((n: number) => void)\n\n  /**\n   * The Tappable associated with this emitter. You can use this to tap (subscribe to) events emitted.\n   */\n  readonly tappable: Tappable<V>\n\n  constructor() {\n    this._lastTapperId = 0\n    this._tappers = new Map()\n    this.tappable = new Tappable({\n      tapToSource: (cb: Tapper<V>) => this._tap(cb),\n    })\n  }\n\n  _tap(cb: Tapper<V>): Untap {\n    const tapperId = this._lastTapperId++\n    this._tappers.set(tapperId, cb)\n    this._onNumberOfTappersChangeListener?.(this._tappers.size)\n    return () => {\n      this._removeTapperById(tapperId)\n    }\n  }\n\n  _removeTapperById(id: number) {\n    const oldSize = this._tappers.size\n    this._tappers.delete(id)\n    const newSize = this._tappers.size\n    if (oldSize !== newSize) {\n      this._onNumberOfTappersChangeListener?.(newSize)\n    }\n  }\n\n  /**\n   * Emit a value.\n   *\n   * @param payload - The value to be emitted.\n   */\n  emit(payload: V) {\n    for (const cb of this._tappers.values()) {\n      cb(payload)\n    }\n  }\n\n  /**\n   * Checks whether the emitter has tappers (subscribers).\n   */\n  hasTappers() {\n    return this._tappers.size !== 0\n  }\n\n  /**\n   * Calls callback when the number of tappers (subscribers) changes.\n   *\n   * @example\n   * ```ts\n   * emitter.onNumberOfTappersChange((n) => {\n   *   console.log(\"number of tappers changed:\", n)\n   * })\n   * ```\n   */\n  onNumberOfTappersChange(cb: (n: number) => void) {\n    this._onNumberOfTappersChangeListener = cb\n  }\n}\n", "import type Ticker from '../Ticker'\nimport Emitter from '../utils/Emitter'\nimport type {default as Tappable} from '../utils/Tappable'\nimport type {IDerivation} from './IDerivation'\n\n/**\n * An event emitter that emits events on changes to a derivation.\n */\nexport default class DerivationEmitter<V> {\n  private _derivation: IDerivation<V>\n  private _ticker: Ticker\n  private _emitter: Emitter<V>\n  private _lastValue: undefined | V\n  private _lastValueRecorded: boolean\n  private _hadTappers: boolean\n\n  /**\n   * @param derivation - The derivation to emit events for.\n   * @param ticker - The ticker to use to batch events.\n   */\n  constructor(derivation: IDerivation<V>, ticker: Ticker) {\n    this._derivation = derivation\n    this._ticker = ticker\n    this._emitter = new Emitter()\n    this._emitter.onNumberOfTappersChange(() => {\n      this._reactToNumberOfTappersChange()\n    })\n    this._hadTappers = false\n    this._lastValueRecorded = false\n    this._lastValue = undefined\n    return this\n  }\n\n  private _possiblyMarkAsStale = () => {\n    this._ticker.onThisOrNextTick(this._refresh)\n  }\n\n  private _reactToNumberOfTappersChange() {\n    const hasTappers = this._emitter.hasTappers()\n    if (hasTappers !== this._hadTappers) {\n      this._hadTappers = hasTappers\n      if (hasTappers) {\n        this._derivation.addDependent(this._possiblyMarkAsStale)\n      } else {\n        this._derivation.removeDependent(this._possiblyMarkAsStale)\n      }\n    }\n  }\n\n  /**\n   * The tappable associated with the emitter. You can use it to tap (subscribe to) the underlying derivation.\n   */\n  tappable(): Tappable<V> {\n    return this._emitter.tappable\n  }\n\n  private _refresh = () => {\n    const newValue = this._derivation.getValue()\n    if (newValue === this._lastValue && this._lastValueRecorded === true) return\n    this._lastValue = newValue\n    this._lastValueRecorded = true\n    this._emitter.emit(newValue)\n  }\n}\n", "import Emitter from '../utils/Emitter'\nimport type {default as Tappable} from '../utils/Tappable'\nimport type {IDerivation} from './IDerivation'\n\n/**\n * Like DerivationEmitter, but with a different performance model. DerivationValuelessEmitter emits every time the\n * derivation is updated, even if the value didn't change, and tappers are called without the value. The advantage of\n * this is that you have control over when the underlying derivation is freshened, it won't automatically be freshened\n * by the emitter.\n */\nexport default class DerivationValuelessEmitter<V> {\n  _derivation: IDerivation<V>\n  _emitter: Emitter<void>\n  _hadTappers: boolean\n\n  constructor(\n    derivation: IDerivation<V>,\n    readonly dontEmitValues: boolean = false,\n  ) {\n    this._derivation = derivation\n    this._emitter = new Emitter()\n    this._emitter.onNumberOfTappersChange(() => {\n      this._reactToNumberOfTappersChange()\n    })\n    this._hadTappers = false\n    return this\n  }\n\n  private _possiblyMarkAsStale = () => {\n    this._emitter.emit(undefined)\n  }\n\n  _reactToNumberOfTappersChange() {\n    const hasTappers = this._emitter.hasTappers()\n    if (hasTappers !== this._hadTappers) {\n      this._hadTappers = hasTappers\n      if (hasTappers) {\n        this._derivation.addDependent(this._possiblyMarkAsStale)\n      } else {\n        this._derivation.removeDependent(this._possiblyMarkAsStale)\n      }\n    }\n  }\n\n  /**\n   * The tappable associated with the emitter. You can use it to tap (subscribe to) the underlying derivation.\n   */\n  tappable(): Tappable<void> {\n    return this._emitter.tappable\n  }\n}\n", "import type Ticker from '../Ticker'\nimport type {$IntentionalAny, VoidFn} from '../types'\nimport type Tappable from '../utils/Tappable'\n\ntype IDependent = (msgComingFrom: IDerivation<$IntentionalAny>) => void\n\n/**\n * Common interface for derivations.\n */\nexport interface IDerivation<V> {\n  /**\n   * Whether the object is a derivation.\n   */\n  isDerivation: true\n\n  /**\n   * Whether the derivation is hot.\n   */\n  isHot: boolean\n\n  /**\n   * Returns a `Tappable` of the changes of this derivation.\n   */\n  changes(ticker: Ticker): Tappable<V>\n\n  /**\n   * Like {@link changes} but with a different performance model. `changesWithoutValues` returns a {@link Tappable} that\n   * updates every time the derivation is updated, even if the value didn't change, and the callback is called without\n   * the value. The advantage of this is that you have control over when the derivation is freshened, it won't\n   * automatically be kept fresh.\n   */\n  changesWithoutValues(): Tappable<void>\n\n  /**\n   * Keep the derivation hot, even if there are no tappers (subscribers).\n   */\n  keepHot(): VoidFn\n\n  /**\n   * Convenience method that taps (subscribes to) the derivation using `this.changes(ticker).tap(fn)` and immediately calls\n   * the callback with the current value.\n   *\n   * @param ticker - The ticker to use for batching.\n   * @param fn - The callback to call on update.\n   *\n   * @see changes\n   */\n  tapImmediate(ticker: Ticker, fn: (cb: V) => void): VoidFn\n\n  /**\n   * Add a derivation as a dependent of this derivation.\n   *\n   * @param d - The derivation to be made a dependent of this derivation.\n   *\n   * @see removeDependent\n   */\n  addDependent(d: IDependent): void\n\n  /**\n   * Remove a derivation as a dependent of this derivation.\n   *\n   * @param d - The derivation to be removed from as a dependent of this derivation.\n   *\n   * @see addDependent\n   */\n  removeDependent(d: IDependent): void\n\n  /**\n   * Gets the current value of the derivation. If the value is stale, it causes the derivation to freshen.\n   */\n  getValue(): V\n\n  /**\n   * Creates a new derivation from this derivation using the provided mapping function. The new derivation's value will be\n   * `fn(thisDerivation.getValue())`.\n   *\n   * @param fn - The mapping function to use. Note: it accepts a plain value, not a derivation.\n   */\n  map<T>(fn: (v: V) => T): IDerivation<T>\n\n  /**\n   * Same as {@link IDerivation.map}, but the mapping function can also return a derivation, in which case the derivation returned\n   * by `flatMap` takes the value of that derivation.\n   *\n   * @example\n   * ```ts\n   * // Simply using map() here would return the inner derivation when we call getValue()\n   * new Box(3).derivation.map((value) => new Box(value).derivation).getValue()\n   *\n   * // Using flatMap() eliminates the inner derivation\n   * new Box(3).derivation.flatMap((value) => new Box(value).derivation).getValue()\n   * ```\n   *\n   * @param fn - The mapping function to use. Note: it accepts a plain value, not a derivation.\n   */\n  flatMap<R>(\n    fn: (v: V) => R,\n  ): IDerivation<R extends IDerivation<infer T> ? T : R>\n}\n\n/**\n * Returns whether `d` is a derivation.\n */\nexport function isDerivation(d: any): d is IDerivation<unknown> {\n  return d && d.isDerivation && d.isDerivation === true\n}\n", "import type {$FixMe} from '../types'\nimport AbstractDerivation from './AbstractDerivation'\nimport type {IDerivation} from './IDerivation'\nimport {isDerivation} from './IDerivation'\n\nenum UPDATE_NEEDED_FROM {\n  none = 0,\n  dep = 1,\n  inner = 2,\n}\n\nconst makeFlatMapDerivationClass = () => {\n  class FlatMapDerivation<V, DepType> extends AbstractDerivation<V> {\n    private _innerDerivation: undefined | null | IDerivation<V>\n    private _staleDependency: UPDATE_NEEDED_FROM\n\n    static displayName = 'flatMap'\n\n    constructor(\n      readonly _depDerivation: IDerivation<DepType>,\n      readonly _fn: (v: DepType) => IDerivation<V> | V,\n    ) {\n      super()\n      this._innerDerivation = undefined\n      this._staleDependency = UPDATE_NEEDED_FROM.dep\n\n      this._addDependency(_depDerivation)\n\n      return this\n    }\n\n    _recalculateHot() {\n      const updateNeededFrom = this._staleDependency\n      this._staleDependency = UPDATE_NEEDED_FROM.none\n\n      if (updateNeededFrom === UPDATE_NEEDED_FROM.inner) {\n        // @ts-ignore\n        return this._innerDerivation.getValue()\n      }\n\n      const possibleInnerDerivation = this._fn(this._depDerivation.getValue())\n\n      if (isDerivation(possibleInnerDerivation)) {\n        this._innerDerivation = possibleInnerDerivation\n        this._addDependency(possibleInnerDerivation)\n        return possibleInnerDerivation.getValue()\n      } else {\n        return possibleInnerDerivation\n      }\n    }\n\n    protected _recalculateCold() {\n      const possibleInnerDerivation = this._fn(this._depDerivation.getValue())\n\n      if (isDerivation(possibleInnerDerivation)) {\n        return possibleInnerDerivation.getValue()\n      } else {\n        return possibleInnerDerivation\n      }\n    }\n\n    protected _recalculate() {\n      return this.isHot ? this._recalculateHot() : this._recalculateCold()\n    }\n\n    protected _reactToDependencyBecomingStale(\n      msgComingFrom: IDerivation<unknown>,\n    ) {\n      const updateNeededFrom =\n        msgComingFrom === this._depDerivation\n          ? UPDATE_NEEDED_FROM.dep\n          : UPDATE_NEEDED_FROM.inner\n\n      if (\n        updateNeededFrom === UPDATE_NEEDED_FROM.inner &&\n        msgComingFrom !== this._innerDerivation\n      ) {\n        throw Error(\n          `got a _reactToDependencyBecomingStale() from neither the dep nor the inner derivation`,\n        )\n      }\n\n      if (this._staleDependency === UPDATE_NEEDED_FROM.none) {\n        this._staleDependency = updateNeededFrom\n\n        if (updateNeededFrom === UPDATE_NEEDED_FROM.dep) {\n          this._removeInnerDerivation()\n        }\n      } else if (this._staleDependency === UPDATE_NEEDED_FROM.dep) {\n      } else {\n        if (updateNeededFrom === UPDATE_NEEDED_FROM.dep) {\n          this._staleDependency = UPDATE_NEEDED_FROM.dep\n          this._removeInnerDerivation()\n        }\n      }\n    }\n\n    private _removeInnerDerivation() {\n      if (this._innerDerivation) {\n        this._removeDependency(this._innerDerivation)\n        this._innerDerivation = undefined\n      }\n    }\n\n    protected _keepHot() {\n      this._staleDependency = UPDATE_NEEDED_FROM.dep\n      this.getValue()\n    }\n\n    protected _becomeCold() {\n      this._staleDependency = UPDATE_NEEDED_FROM.dep\n      this._removeInnerDerivation()\n    }\n  }\n  return FlatMapDerivation\n}\n\nlet cls: ReturnType<typeof makeFlatMapDerivationClass> | undefined = undefined\n\nexport default function flatMap<V, R>(\n  dep: IDerivation<V>,\n  fn: (v: V) => R,\n): IDerivation<R extends IDerivation<infer T> ? T : R> {\n  if (!cls) {\n    cls = makeFlatMapDerivationClass()\n  }\n  return new cls(dep, fn) as $FixMe\n}\n", "import AbstractDerivation from './AbstractDerivation'\nimport type {IDerivation} from './IDerivation'\n\n// Exporting from a function because of the circular dependency with AbstractDerivation\nconst makeMapDerivationClass = () =>\n  class MapDerivation<T, V> extends AbstractDerivation<V> {\n    constructor(\n      private readonly _dep: IDerivation<T>,\n      private readonly _fn: (t: T) => V,\n    ) {\n      super()\n      this._addDependency(_dep)\n    }\n\n    _recalculate() {\n      return this._fn(this._dep.getValue())\n    }\n\n    _reactToDependencyBecomingStale() {}\n  }\n\nlet cls: ReturnType<typeof makeMapDerivationClass> | undefined = undefined\n\nexport default function flatMap<V, R>(\n  dep: IDerivation<V>,\n  fn: (v: V) => R,\n): IDerivation<R> {\n  if (!cls) {\n    cls = makeMapDerivationClass()\n  }\n  return new cls(dep, fn)\n}\n", "interface Node<Data> {\n  next: undefined | Node<Data>\n  data: Data\n}\n\n/**\n * Just a simple LinkedList\n */\nexport default class Stack<Data> {\n  _head: undefined | Node<Data>\n\n  constructor() {\n    this._head = undefined\n  }\n\n  peek() {\n    return this._head && this._head.data\n  }\n\n  pop() {\n    const head = this._head\n    if (!head) {\n      return undefined\n    }\n    this._head = head.next\n    return head.data\n  }\n\n  push(data: Data) {\n    const node = {next: this._head, data}\n    this._head = node\n  }\n}\n", "import type {$IntentionalAny} from '../../types'\nimport Stack from '../../utils/Stack'\nimport type {IDerivation} from '../IDerivation'\n\nfunction createMechanism() {\n  const noop = () => {}\n\n  const stack = new Stack<Collector>()\n  const noopCollector: Collector = noop\n\n  type Collector = (d: IDerivation<$IntentionalAny>) => void\n\n  const pushCollector = (collector: Collector): void => {\n    stack.push(collector)\n  }\n\n  const popCollector = (collector: Collector): void => {\n    const existing = stack.peek()\n    if (existing !== collector) {\n      throw new Error(`Popped collector is not on top of the stack`)\n    }\n    stack.pop()\n  }\n\n  const startIgnoringDependencies = () => {\n    stack.push(noopCollector)\n  }\n\n  const stopIgnoringDependencies = () => {\n    if (stack.peek() !== noopCollector) {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn('This should never happen')\n      }\n    } else {\n      stack.pop()\n    }\n  }\n\n  const reportResolutionStart = (d: IDerivation<$IntentionalAny>) => {\n    const possibleCollector = stack.peek()\n    if (possibleCollector) {\n      possibleCollector(d)\n    }\n\n    stack.push(noopCollector)\n  }\n\n  const reportResolutionEnd = (_d: IDerivation<$IntentionalAny>) => {\n    stack.pop()\n  }\n\n  return {\n    type: 'Dataverse_discoveryMechanism' as 'Dataverse_discoveryMechanism',\n    startIgnoringDependencies,\n    stopIgnoringDependencies,\n    reportResolutionStart,\n    reportResolutionEnd,\n    pushCollector,\n    popCollector,\n  }\n}\n\nfunction getSharedMechanism(): ReturnType<typeof createMechanism> {\n  const varName = '__dataverse_discoveryMechanism_sharedStack'\n  const root =\n    typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n      ? global\n      : {}\n  if (root) {\n    const existingMechanism: ReturnType<typeof createMechanism> | undefined =\n      // @ts-ignore ignore\n      root[varName]\n    if (\n      existingMechanism &&\n      typeof existingMechanism === 'object' &&\n      existingMechanism.type === 'Dataverse_discoveryMechanism'\n    ) {\n      return existingMechanism\n    } else {\n      const mechanism = createMechanism()\n      // @ts-ignore ignore\n      root[varName] = mechanism\n      return mechanism\n    }\n  } else {\n    return createMechanism()\n  }\n}\n\nexport const {\n  startIgnoringDependencies,\n  stopIgnoringDependencies,\n  reportResolutionEnd,\n  reportResolutionStart,\n  pushCollector,\n  popCollector,\n} = getSharedMechanism()\n", "import type Ticker from '../Ticker'\nimport type {$IntentionalAny, VoidFn} from '../types'\nimport type Tappable from '../utils/Tappable'\nimport DerivationEmitter from './DerivationEmitter'\nimport DerivationValuelessEmitter from './DerivationValuelessEmitter'\nimport flatMap from './flatMap'\nimport type {IDerivation} from './IDerivation'\nimport map from './map'\nimport {\n  reportResolutionEnd,\n  reportResolutionStart,\n} from './prism/discoveryMechanism'\n\ntype IDependent = (msgComingFrom: IDerivation<$IntentionalAny>) => void\n\n/**\n * Represents a derivation whose changes can be tracked. To be used as the base class for all derivations.\n */\nexport default abstract class AbstractDerivation<V> implements IDerivation<V> {\n  /**\n   * Whether the object is a derivation.\n   */\n  readonly isDerivation: true = true\n  private _didMarkDependentsAsStale: boolean = false\n  private _isHot: boolean = false\n\n  private _isFresh: boolean = false\n\n  /**\n   * @internal\n   */\n  protected _lastValue: undefined | V = undefined\n\n  /**\n   * @internal\n   */\n  protected _dependents: Set<IDependent> = new Set()\n\n  /**\n   * @internal\n   */\n  protected _dependencies: Set<IDerivation<$IntentionalAny>> = new Set()\n\n  /**\n   * @internal\n   */\n  protected abstract _recalculate(): V\n\n  /**\n   * @internal\n   */\n  protected abstract _reactToDependencyBecomingStale(\n    which: IDerivation<unknown>,\n  ): void\n\n  constructor() {}\n\n  /**\n   * Whether the derivation is hot.\n   */\n  get isHot(): boolean {\n    return this._isHot\n  }\n\n  /**\n   * @internal\n   */\n  protected _addDependency(d: IDerivation<$IntentionalAny>) {\n    if (this._dependencies.has(d)) return\n    this._dependencies.add(d)\n    if (this._isHot) d.addDependent(this._internal_markAsStale)\n  }\n\n  /**\n   * @internal\n   */\n  protected _removeDependency(d: IDerivation<$IntentionalAny>) {\n    if (!this._dependencies.has(d)) return\n    this._dependencies.delete(d)\n    if (this._isHot) d.removeDependent(this._internal_markAsStale)\n  }\n\n  /**\n   * Returns a `Tappable` of the changes of this derivation.\n   */\n  changes(ticker: Ticker): Tappable<V> {\n    return new DerivationEmitter(this, ticker).tappable()\n  }\n\n  /**\n   * Like {@link AbstractDerivation.changes} but with a different performance model. `changesWithoutValues` returns a `Tappable` that\n   * updates every time the derivation is updated, even if the value didn't change, and the callback is called without\n   * the value. The advantage of this is that you have control over when the derivation is freshened, it won't\n   * automatically be kept fresh.\n   */\n  changesWithoutValues(): Tappable<void> {\n    return new DerivationValuelessEmitter(this).tappable()\n  }\n\n  /**\n   * Keep the derivation hot, even if there are no tappers (subscribers).\n   */\n  keepHot() {\n    return this.changesWithoutValues().tap(() => {})\n  }\n\n  /**\n   * Convenience method that taps (subscribes to) the derivation using `this.changes(ticker).tap(fn)` and immediately calls\n   * the callback with the current value.\n   *\n   * @param ticker - The ticker to use for batching.\n   * @param fn - The callback to call on update.\n   *\n   * @see changes\n   */\n  tapImmediate(ticker: Ticker, fn: (cb: V) => void): VoidFn {\n    const untap = this.changes(ticker).tap(fn)\n    fn(this.getValue())\n    return untap\n  }\n\n  /**\n   * Add a derivation as a dependent of this derivation.\n   *\n   * @param d - The derivation to be made a dependent of this derivation.\n   *\n   * @see removeDependent\n   */\n  // TODO: document this better, what are dependents?\n  addDependent(d: IDependent) {\n    const hadDepsBefore = this._dependents.size > 0\n    this._dependents.add(d)\n    const hasDepsNow = this._dependents.size > 0\n    if (hadDepsBefore !== hasDepsNow) {\n      this._reactToNumberOfDependentsChange()\n    }\n  }\n\n  /**\n   * Remove a derivation as a dependent of this derivation.\n   *\n   * @param d - The derivation to be removed from as a dependent of this derivation.\n   *\n   * @see addDependent\n   */\n  removeDependent(d: IDependent) {\n    const hadDepsBefore = this._dependents.size > 0\n    this._dependents.delete(d)\n    const hasDepsNow = this._dependents.size > 0\n    if (hadDepsBefore !== hasDepsNow) {\n      this._reactToNumberOfDependentsChange()\n    }\n  }\n\n  /**\n   * This is meant to be called by subclasses\n   *\n   * @sealed\n   * @internal\n   */\n  protected _markAsStale(which: IDerivation<$IntentionalAny>) {\n    this._internal_markAsStale(which)\n  }\n\n  private _internal_markAsStale = (which: IDerivation<$IntentionalAny>) => {\n    this._reactToDependencyBecomingStale(which)\n\n    if (this._didMarkDependentsAsStale) return\n\n    this._didMarkDependentsAsStale = true\n    this._isFresh = false\n\n    for (const dependent of this._dependents) {\n      dependent(this)\n    }\n  }\n\n  /**\n   * Gets the current value of the derivation. If the value is stale, it causes the derivation to freshen.\n   */\n  getValue(): V {\n    /**\n     * TODO We should prevent (or warn about) a common mistake users make, which is reading the value of\n     * a derivation in the body of a react component (e.g. `der.getValue()` (often via `val()`) instead of `useVal()`\n     * or `uesPrism()`).\n     *\n     * Although that's the most common example of this mistake, you can also find it outside of react components.\n     * Basically the user runs `der.getValue()` assuming the read is detected by a wrapping prism when it's not.\n     *\n     * Sometiems the derivation isn't even hot when the user assumes it is.\n     *\n     * We can fix this type of mistake by:\n     * 1. Warning the user when they call `getValue()` on a cold derivation.\n     * 2. Warning the user about calling `getValue()` on a hot-but-stale derivation\n     *    if `getValue()` isn't called by a known mechanism like a `DerivationEmitter`.\n     *\n     * Design constraints:\n     * - This fix should not have a perf-penalty in production. Perhaps use a global flag + `process.env.NODE_ENV !== 'production'`\n     *   to enable it.\n     * - In the case of `DerivationValuelessEmitter`, we don't control when the user calls\n     *   `getValue()` (as opposed to `DerivationEmitter` which calls `getValue()` directly).\n     *   Perhaps we can disable the check in that case.\n     * - Probably the best place to add this check is right here in this method plus some changes to `reportResulutionStart()`,\n     *   which would have to be changed to let the caller know if there is an actual collector (a prism)\n     *   present in its stack.\n     */\n    reportResolutionStart(this)\n\n    if (!this._isFresh) {\n      const newValue = this._recalculate()\n      this._lastValue = newValue\n      if (this._isHot) {\n        this._isFresh = true\n        this._didMarkDependentsAsStale = false\n      }\n    }\n\n    reportResolutionEnd(this)\n    return this._lastValue!\n  }\n\n  private _reactToNumberOfDependentsChange() {\n    const shouldBecomeHot = this._dependents.size > 0\n\n    if (shouldBecomeHot === this._isHot) return\n\n    this._isHot = shouldBecomeHot\n    this._didMarkDependentsAsStale = false\n    this._isFresh = false\n    if (shouldBecomeHot) {\n      for (const d of this._dependencies) {\n        d.addDependent(this._internal_markAsStale)\n      }\n      this._keepHot()\n    } else {\n      for (const d of this._dependencies) {\n        d.removeDependent(this._internal_markAsStale)\n      }\n      this._becomeCold()\n    }\n  }\n\n  /**\n   * @internal\n   */\n  protected _keepHot() {}\n\n  /**\n   * @internal\n   */\n  protected _becomeCold() {}\n\n  /**\n   * Creates a new derivation from this derivation using the provided mapping function. The new derivation's value will be\n   * `fn(thisDerivation.getValue())`.\n   *\n   * @param fn - The mapping function to use. Note: it accepts a plain value, not a derivation.\n   */\n  map<T>(fn: (v: V) => T): IDerivation<T> {\n    return map(this, fn)\n  }\n\n  /**\n   * Same as {@link AbstractDerivation.map}, but the mapping function can also return a derivation, in which case the derivation returned\n   * by `flatMap` takes the value of that derivation.\n   *\n   * @example\n   * ```ts\n   * // Simply using map() here would return the inner derivation when we call getValue()\n   * new Box(3).derivation.map((value) => new Box(value).derivation).getValue()\n   *\n   * // Using flatMap() eliminates the inner derivation\n   * new Box(3).derivation.flatMap((value) => new Box(value).derivation).getValue()\n   * ```\n   *\n   * @param fn - The mapping function to use. Note: it accepts a plain value, not a derivation.\n   */\n  flatMap<R>(\n    fn: (v: V) => R,\n  ): IDerivation<R extends IDerivation<infer T> ? T : R> {\n    return flatMap(this, fn)\n  }\n}\n", "import type {VoidFn} from '../types'\nimport AbstractDerivation from './AbstractDerivation'\n\nconst noop = () => {}\n\n/**\n * Represents a derivation based on a tappable (subscribable) data source.\n */\nexport default class DerivationFromSource<V> extends AbstractDerivation<V> {\n  private _untapFromChanges: () => void\n  private _cachedValue: undefined | V\n  private _hasCachedValue: boolean\n\n  /**\n   * @param _tapToSource - A function that takes a listener and subscribes it to the underlying data source.\n   * @param _getValueFromSource - A function that returns the current value of the data source.\n   */\n  constructor(\n    private readonly _tapToSource: (listener: (newValue: V) => void) => VoidFn,\n    private readonly _getValueFromSource: () => V,\n  ) {\n    super()\n    this._untapFromChanges = noop\n    this._cachedValue = undefined\n    this._hasCachedValue = false\n  }\n\n  /**\n   * @internal\n   */\n  _recalculate() {\n    if (this.isHot) {\n      if (!this._hasCachedValue) {\n        this._cachedValue = this._getValueFromSource()\n        this._hasCachedValue = true\n      }\n      return this._cachedValue as V\n    } else {\n      return this._getValueFromSource()\n    }\n  }\n\n  /**\n   * @internal\n   */\n  _keepHot() {\n    this._hasCachedValue = false\n    this._cachedValue = undefined\n\n    this._untapFromChanges = this._tapToSource((newValue) => {\n      this._hasCachedValue = true\n      this._cachedValue = newValue\n      this._markAsStale(this)\n    })\n  }\n\n  /**\n   * @internal\n   */\n  _becomeCold() {\n    this._untapFromChanges()\n    this._untapFromChanges = noop\n\n    this._hasCachedValue = false\n    this._cachedValue = undefined\n  }\n\n  /**\n   * @internal\n   */\n  _reactToDependencyBecomingStale() {}\n}\n", "import type {$IntentionalAny} from './types'\n\ntype PathToProp = Array<string | number>\n\ntype PointerMeta = {\n  root: {}\n  path: (string | number)[]\n}\n\n/** We are using an empty object as a WeakMap key for storing pointer meta data */\ntype WeakPointerKey = {}\n\nexport type UnindexableTypesForPointer =\n  | number\n  | string\n  | boolean\n  | null\n  | void\n  | undefined\n  | Function // eslint-disable-line @typescript-eslint/ban-types\n\nexport type UnindexablePointer = {\n  [K in $IntentionalAny]: Pointer<undefined>\n}\n\nconst pointerMetaWeakMap = new WeakMap<WeakPointerKey, PointerMeta>()\nconst cachedSubPathPointersWeakMap = new WeakMap<\n  WeakPointerKey,\n  Map<string | number, Pointer<unknown>>\n>()\n\n/**\n * A wrapper type for the type a `Pointer` points to.\n */\nexport type PointerType<O> = {\n  /**\n   * Only accessible via the type system.\n   * This is a helper for getting the underlying pointer type\n   * via the type space.\n   */\n  $$__pointer_type: O\n}\n\n/**\n * The type of {@link Atom} pointers. See {@link pointer|pointer()} for an\n * explanation of pointers.\n *\n * @see Atom\n *\n * @remarks\n * The Pointer type is quite tricky because it doesn't play well with `any` and other inexact types.\n * Here is an example that one would expect to work, but currently doesn't:\n * ```ts\n * declare function expectAnyPointer(pointer: Pointer<any>): void\n *\n * expectAnyPointer(null as Pointer<{}>) // this shows as a type error because Pointer<{}> is not assignable to Pointer<any>, even though it should\n * ```\n *\n * The current solution is to just avoid using `any` with pointer-related code (or type-test it well).\n * But if you enjoy solving typescript puzzles, consider fixing this :)\n * Potentially, [TypeScript variance annotations in 4.7+](https://devblogs.microsoft.com/typescript/announcing-typescript-4-7-beta/#optional-variance-annotations-for-type-parameters)\n * might be able to help us.\n */\nexport type Pointer<O> = PointerType<O> &\n  // `Exclude<O, undefined>` will remove `undefined` from the first type\n  // `undefined extends O ? undefined : never` will give us `undefined` if `O` is `... | undefined`\n  PointerInner<Exclude<O, undefined>, undefined extends O ? undefined : never>\n\n// By separating the `O` (non-undefined) from the `undefined` or `never`, we\n// can properly use `O extends ...` to determine the kind of potential value\n// without actually discarding optionality information.\ntype PointerInner<O, Optional> = O extends UnindexableTypesForPointer\n  ? UnindexablePointer\n  : unknown extends O\n  ? UnindexablePointer\n  : O extends (infer T)[]\n  ? Pointer<T>[]\n  : O extends {}\n  ? {\n      [K in keyof O]-?: Pointer<O[K] | Optional>\n    }\n  : UnindexablePointer\n\nconst pointerMetaSymbol = Symbol('pointerMeta')\n\nconst proxyHandler = {\n  get(\n    pointerKey: WeakPointerKey,\n    prop: string | typeof pointerMetaSymbol,\n  ): $IntentionalAny {\n    if (prop === pointerMetaSymbol) return pointerMetaWeakMap.get(pointerKey)!\n\n    let subPathPointers = cachedSubPathPointersWeakMap.get(pointerKey)\n    if (!subPathPointers) {\n      subPathPointers = new Map()\n      cachedSubPathPointersWeakMap.set(pointerKey, subPathPointers)\n    }\n\n    const existing = subPathPointers.get(prop)\n    if (existing !== undefined) return existing\n\n    const meta = pointerMetaWeakMap.get(pointerKey)!\n\n    const subPointer = pointer({root: meta.root, path: [...meta.path, prop]})\n    subPathPointers.set(prop, subPointer)\n    return subPointer\n  },\n}\n\n/**\n * Returns the metadata associated with the pointer. Usually the root object and\n * the path.\n *\n * @param p - The pointer.\n */\nexport const getPointerMeta = <_>(p: PointerType<_>): PointerMeta => {\n  // @ts-ignore @todo\n  const meta: PointerMeta = p[\n    pointerMetaSymbol as unknown as $IntentionalAny\n  ] as $IntentionalAny\n  return meta\n}\n\n/**\n * Returns the root object and the path of the pointer.\n *\n * @example\n * ```ts\n * const {root, path} = getPointerParts(pointer)\n * ```\n *\n * @param p - The pointer.\n *\n * @returns An object with two properties: `root`-the root object or the pointer, and `path`-the path of the pointer. `path` is an array of the property-chain.\n */\nexport const getPointerParts = <_>(\n  p: Pointer<_>,\n): {root: {}; path: PathToProp} => {\n  const {root, path} = getPointerMeta(p)\n  return {root, path}\n}\n\n/**\n * Creates a pointer to a (nested) property of an {@link Atom}.\n *\n * @remarks\n * Pointers are used to make derivations of properties or nested properties of\n * {@link Atom|Atoms}.\n *\n * Pointers also allow easy construction of new pointers pointing to nested members\n * of the root object, by simply using property chaining. E.g. `somePointer.a.b` will\n * create a new pointer that has `'a'` and `'b'` added to the path of `somePointer`.\n *\n * @example\n * ```ts\n * // Here, sum is a derivation that updates whenever the a or b prop of someAtom does.\n * const sum = prism(() => {\n *   return val(pointer({root: someAtom, path: ['a']})) + val(pointer({root: someAtom, path: ['b']}));\n * });\n *\n * // Note, atoms have a convenience Atom.pointer property that points to the root,\n * // which you would normally use in this situation.\n * const sum = prism(() => {\n *   return val(someAtom.pointer.a) + val(someAtom.pointer.b);\n * });\n * ```\n *\n * @param args - The pointer parameters.\n *\n * @typeParam O - The type of the value being pointed to.\n */\nfunction pointer<O>(args: {root: {}; path?: Array<string | number>}) {\n  const meta: PointerMeta = {\n    root: args.root as $IntentionalAny,\n    path: args.path ?? [],\n  }\n  const pointerKey: WeakPointerKey = {}\n  pointerMetaWeakMap.set(pointerKey, meta)\n  return new Proxy(pointerKey, proxyHandler) as Pointer<O>\n}\n\nexport default pointer\n\n/**\n * Returns whether `p` is a pointer.\n */\nexport const isPointer = (p: $IntentionalAny): p is Pointer<unknown> => {\n  return p && !!getPointerMeta(p)\n}\n", "import type {$FixMe, $IntentionalAny} from '../types'\n\nexport default function updateDeep<S>(\n  state: S,\n  path: (string | number | undefined)[],\n  reducer: (...args: $IntentionalAny[]) => $IntentionalAny,\n): S {\n  if (path.length === 0) return reducer(state)\n  return hoop(state, path as $IntentionalAny, reducer)\n}\n\nconst hoop = (\n  s: $FixMe,\n  path: (string | number)[],\n  reducer: $FixMe,\n): $FixMe => {\n  if (path.length === 0) {\n    return reducer(s)\n  }\n  if (Array.isArray(s)) {\n    let [index, ...restOfPath] = path\n    index = parseInt(String(index), 10)\n    if (isNaN(index)) index = 0\n    const oldVal = s[index]\n    const newVal = hoop(oldVal, restOfPath, reducer)\n    if (oldVal === newVal) return s\n    const newS = [...s]\n    newS.splice(index, 1, newVal)\n    return newS\n  } else if (typeof s === 'object' && s !== null) {\n    const [key, ...restOfPath] = path\n    const oldVal = s[key]\n    const newVal = hoop(oldVal, restOfPath, reducer)\n    if (oldVal === newVal) return s\n    const newS = {...s, [key]: newVal}\n    return newS\n  } else {\n    const [key, ...restOfPath] = path\n\n    return {[key]: hoop(undefined, restOfPath, reducer)}\n  }\n}\n", "import get from 'lodash-es/get'\nimport isPlainObject from 'lodash-es/isPlainObject'\nimport last from 'lodash-es/last'\nimport DerivationFromSource from './derivations/DerivationFromSource'\nimport type {IDerivation} from './derivations/IDerivation'\nimport {isDerivation} from './derivations/IDerivation'\nimport type {Pointer, PointerType} from './pointer'\nimport {isPointer} from './pointer'\nimport pointer, {getPointerMeta} from './pointer'\nimport type {$FixMe, $IntentionalAny} from './types'\nimport type {PathBasedReducer} from './utils/PathBasedReducer'\nimport updateDeep from './utils/updateDeep'\n\ntype Listener = (newVal: unknown) => void\n\nenum ValueTypes {\n  Dict,\n  Array,\n  Other,\n}\n\n/**\n * Interface for objects that can provide a derivation at a certain path.\n */\nexport interface IdentityDerivationProvider {\n  /**\n   * @internal\n   * Future: We could consider using a `Symbol.for(\"dataverse/IdentityDerivationProvider\")` as a key here, similar to\n   * how {@link Iterable} works for `of`.\n   */\n  readonly $$isIdentityDerivationProvider: true\n  /**\n   * Returns a derivation of the value at the provided path.\n   *\n   * @param path - The path to create the derivation at.\n   */\n  getIdentityDerivation(path: Array<string | number>): IDerivation<unknown>\n}\n\nconst getTypeOfValue = (v: unknown): ValueTypes => {\n  if (Array.isArray(v)) return ValueTypes.Array\n  if (isPlainObject(v)) return ValueTypes.Dict\n  return ValueTypes.Other\n}\n\nconst getKeyOfValue = (\n  v: unknown,\n  key: string | number,\n  vType: ValueTypes = getTypeOfValue(v),\n): unknown => {\n  if (vType === ValueTypes.Dict && typeof key === 'string') {\n    return (v as $IntentionalAny)[key]\n  } else if (vType === ValueTypes.Array && isValidArrayIndex(key)) {\n    return (v as $IntentionalAny)[key]\n  } else {\n    return undefined\n  }\n}\n\nconst isValidArrayIndex = (key: string | number): boolean => {\n  const inNumber = typeof key === 'number' ? key : parseInt(key, 10)\n  return (\n    !isNaN(inNumber) &&\n    inNumber >= 0 &&\n    inNumber < Infinity &&\n    (inNumber | 0) === inNumber\n  )\n}\n\nclass Scope {\n  children: Map<string | number, Scope> = new Map()\n  identityChangeListeners: Set<Listener> = new Set()\n  constructor(\n    readonly _parent: undefined | Scope,\n    readonly _path: (string | number)[],\n  ) {}\n\n  addIdentityChangeListener(cb: Listener) {\n    this.identityChangeListeners.add(cb)\n  }\n\n  removeIdentityChangeListener(cb: Listener) {\n    this.identityChangeListeners.delete(cb)\n    this._checkForGC()\n  }\n\n  removeChild(key: string | number) {\n    this.children.delete(key)\n    this._checkForGC()\n  }\n\n  getChild(key: string | number) {\n    return this.children.get(key)\n  }\n\n  getOrCreateChild(key: string | number) {\n    let child = this.children.get(key)\n    if (!child) {\n      child = child = new Scope(this, this._path.concat([key]))\n      this.children.set(key, child)\n    }\n    return child\n  }\n\n  _checkForGC() {\n    if (this.identityChangeListeners.size > 0) return\n    if (this.children.size > 0) return\n\n    if (this._parent) {\n      this._parent.removeChild(last(this._path) as string | number)\n    }\n  }\n}\n\n/**\n * Wraps an object whose (sub)properties can be individually tracked.\n */\nexport default class Atom<State extends {}>\n  implements IdentityDerivationProvider\n{\n  private _currentState: State\n  /**\n   * @internal\n   */\n  readonly $$isIdentityDerivationProvider = true\n  private readonly _rootScope: Scope\n  /**\n   * Convenience property that gives you a pointer to the root of the atom.\n   *\n   * @remarks\n   * Equivalent to `pointer({ root: thisAtom, path: [] })`.\n   */\n  readonly pointer: Pointer<State>\n\n  constructor(initialState: State) {\n    this._currentState = initialState\n    this._rootScope = new Scope(undefined, [])\n    this.pointer = pointer({root: this as $FixMe, path: []})\n  }\n\n  /**\n   * Sets the state of the atom.\n   *\n   * @param newState - The new state of the atom.\n   */\n  setState(newState: State) {\n    const oldState = this._currentState\n    this._currentState = newState\n\n    this._checkUpdates(this._rootScope, oldState, newState)\n  }\n\n  /**\n   * Gets the current state of the atom.\n   */\n  getState() {\n    return this._currentState\n  }\n\n  /**\n   * Gets the state of the atom at `path`.\n   */\n  getIn(path: (string | number)[]): unknown {\n    return path.length === 0 ? this.getState() : get(this.getState(), path)\n  }\n\n  /**\n   * Creates a new state object from the current one, where the value at `path`\n   * is replaced by the return value of `reducer`, then sets it.\n   *\n   * @remarks\n   * Doesn't mutate the old state, and preserves referential equality between\n   * values of the old state and the new state where possible.\n   *\n   * @example\n   * ```ts\n   * someAtom.getIn(['a']) // 1\n   * someAtom.reduceState(['a'], (state) => state + 1);\n   * someAtom.getIn(['a']) // 2\n   * ```\n   *\n   * @param path - The path to call the reducer at.\n   * @param reducer - The function to use for creating the new state.\n   */\n  // TODO: Why is this a property and not a method?\n  reduceState: PathBasedReducer<State, State> = (\n    path: $IntentionalAny[],\n    reducer: $IntentionalAny,\n  ) => {\n    const newState = updateDeep(this.getState(), path, reducer)\n    this.setState(newState)\n    return newState\n  }\n\n  /**\n   * Sets the state of the atom at `path`.\n   */\n  setIn(path: $FixMe[], val: $FixMe) {\n    return this.reduceState(path, () => val)\n  }\n\n  private _checkUpdates(scope: Scope, oldState: unknown, newState: unknown) {\n    if (oldState === newState) return\n    for (const cb of scope.identityChangeListeners) {\n      cb(newState)\n    }\n\n    if (scope.children.size === 0) return\n\n    // @todo we can probably skip checking value types\n    const oldValueType = getTypeOfValue(oldState)\n    const newValueType = getTypeOfValue(newState)\n\n    if (oldValueType === ValueTypes.Other && oldValueType === newValueType)\n      return\n\n    for (const [childKey, childScope] of scope.children) {\n      const oldChildVal = getKeyOfValue(oldState, childKey, oldValueType)\n      const newChildVal = getKeyOfValue(newState, childKey, newValueType)\n      this._checkUpdates(childScope, oldChildVal, newChildVal)\n    }\n  }\n\n  private _getOrCreateScopeForPath(path: (string | number)[]): Scope {\n    let curScope = this._rootScope\n    for (const pathEl of path) {\n      curScope = curScope.getOrCreateChild(pathEl)\n    }\n    return curScope\n  }\n\n  private _onPathValueChange = (\n    path: (string | number)[],\n    cb: (v: unknown) => void,\n  ) => {\n    const scope = this._getOrCreateScopeForPath(path)\n    scope.identityChangeListeners.add(cb)\n    const untap = () => {\n      scope.identityChangeListeners.delete(cb)\n    }\n    return untap\n  }\n\n  /**\n   * Returns a new derivation of the value at the provided path.\n   *\n   * @param path - The path to create the derivation at.\n   */\n  getIdentityDerivation(path: Array<string | number>): IDerivation<unknown> {\n    return new DerivationFromSource<$IntentionalAny>(\n      (listener) => this._onPathValueChange(path, listener),\n      () => this.getIn(path),\n    )\n  }\n}\n\nconst identityDerivationWeakMap = new WeakMap<{}, IDerivation<unknown>>()\n\n/**\n * Returns a derivation of the value at the provided pointer. Derivations are\n * cached per pointer.\n *\n * @param pointer - The pointer to return the derivation at.\n */\nexport const valueDerivation = <P extends PointerType<$IntentionalAny>>(\n  pointer: P,\n): IDerivation<P extends PointerType<infer T> ? T : void> => {\n  const meta = getPointerMeta(pointer)\n\n  let derivation = identityDerivationWeakMap.get(meta)\n  if (!derivation) {\n    const root = meta.root\n    if (!isIdentityDerivationProvider(root)) {\n      throw new Error(\n        `Cannot run valueDerivation() on a pointer whose root is not an IdentityChangeProvider`,\n      )\n    }\n    const {path} = meta\n    derivation = root.getIdentityDerivation(path)\n    identityDerivationWeakMap.set(meta, derivation)\n  }\n  return derivation as $IntentionalAny\n}\n\nfunction isIdentityDerivationProvider(\n  val: unknown,\n): val is IdentityDerivationProvider {\n  return (\n    typeof val === 'object' &&\n    val !== null &&\n    (val as $IntentionalAny)['$$isIdentityDerivationProvider'] === true\n  )\n}\n\n/**\n * Convenience function that returns a plain value from its argument, whether it\n * is a pointer, a derivation or a plain value itself.\n *\n * @remarks\n * For pointers, the value is returned by first creating a derivation, so it is\n * reactive e.g. when used in a `prism`.\n *\n * @param input - The argument to return a value from.\n */\nexport const val = <\n  P extends\n    | PointerType<$IntentionalAny>\n    | IDerivation<$IntentionalAny>\n    | undefined\n    | null,\n>(\n  input: P,\n): P extends PointerType<infer T>\n  ? T\n  : P extends IDerivation<infer T>\n  ? T\n  : P extends undefined | null\n  ? P\n  : unknown => {\n  if (isPointer(input)) {\n    return valueDerivation(input).getValue() as $IntentionalAny\n  } else if (isDerivation(input)) {\n    return input.getValue() as $IntentionalAny\n  } else {\n    return input as $IntentionalAny\n  }\n}\n", "import DerivationFromSource from './derivations/DerivationFromSource'\nimport type {IDerivation} from './derivations/IDerivation'\nimport Emitter from './utils/Emitter'\n\n/**\n * Common interface for Box types. Boxes wrap a single value.\n */\nexport interface IBox<V> {\n  /**\n   * Sets the value of the Box.\n   *\n   * @param v - The value to update the Box with.\n   */\n\n  set(v: V): void\n  /**\n   * Gets the value of the Box.\n   *\n   * @remarks\n   * Usages of `get()` aren't tracked, they are only for retrieving the value. To track changes, you need to\n   * create a derivation.\n   *\n   * @see derivation\n   */\n  get(): V\n\n  /**\n   * Creates a derivation of the Box that you can use to track changes to it.\n   */\n  derivation: IDerivation<V>\n}\n\n/**\n * Wraps a single value.\n *\n * @remarks\n * Derivations created with {@link Box.derivation} update based on strict equality (`===`) of the old value and the new one.\n * This also means that property-changes of objects won't be tracked, and that for objects, updates will trigger on changes of\n * reference even if the objects are structurally equal.\n */\nexport default class Box<V> implements IBox<V> {\n  private _publicDerivation: IDerivation<V>\n  private _emitter = new Emitter<V>()\n\n  /**\n   * @param _value - The initial value of the Box.\n   */\n  constructor(\n    /**\n     * @internal\n     */\n    protected _value: V,\n  ) {\n    this._publicDerivation = new DerivationFromSource(\n      (listener) => this._emitter.tappable.tap(listener),\n      this.get.bind(this),\n    )\n  }\n\n  /**\n   * Sets the value of the Box.\n   *\n   * @param v - The value to update the Box with.\n   */\n  set(v: V) {\n    if (v === this._value) return\n    this._value = v\n    this._emitter.emit(v)\n  }\n\n  /**\n   * Gets the value of the Box.\n   *\n   * Note: usages of `get()` aren't tracked, they are only for retrieving the value. To track changes, you need to\n   * create a derivation.\n   *\n   * @see Box.derivation\n   */\n  get() {\n    return this._value\n  }\n\n  /**\n   * Creates a derivation of the Box that you can use to track changes to it.\n   */\n  get derivation() {\n    return this._publicDerivation\n  }\n}\n", "import AbstractDerivation from './AbstractDerivation'\n\n/**\n * A derivation whose value never changes.\n */\nexport default class ConstantDerivation<V> extends AbstractDerivation<V> {\n  private readonly _v: V\n\n  /**\n   * @param v - The value of the derivation.\n   */\n  constructor(v: V) {\n    super()\n    this._v = v\n    return this\n  }\n\n  /**\n   * @internal\n   */\n  _recalculate() {\n    return this._v\n  }\n\n  /**\n   * @internal\n   */\n  _reactToDependencyBecomingStale() {}\n}\n", "import {valueDerivation} from '../Atom'\nimport type {Pointer} from '../pointer'\nimport {isPointer} from '../pointer'\nimport type {IDerivation} from './IDerivation'\nimport {isDerivation} from './IDerivation'\n\nexport default function* iterateAndCountTicks<V>(\n  pointerOrDerivation: IDerivation<V> | Pointer<V>,\n): Generator<{value: V; ticks: number}, void, void> {\n  let d\n  if (isPointer(pointerOrDerivation)) {\n    d = valueDerivation(pointerOrDerivation) as IDerivation<V>\n  } else if (isDerivation(pointerOrDerivation)) {\n    d = pointerOrDerivation\n  } else {\n    throw new Error(`Only pointers and derivations are supported`)\n  }\n\n  let ticksCountedSinceLastYield = 0\n  const untap = d.changesWithoutValues().tap(() => {\n    ticksCountedSinceLastYield++\n  })\n\n  try {\n    while (true) {\n      const ticks = ticksCountedSinceLastYield\n      ticksCountedSinceLastYield = 0\n      yield {value: d.getValue(), ticks}\n    }\n  } finally {\n    untap()\n  }\n}\n", "type ICallback = (t: number) => void\n\nfunction createRafTicker() {\n  const ticker = new Ticker()\n\n  if (typeof window !== 'undefined') {\n    /**\n     * @remarks\n     * TODO users should also be able to define their own ticker.\n     */\n    const onAnimationFrame = (t: number) => {\n      ticker.tick(t)\n      window.requestAnimationFrame(onAnimationFrame)\n    }\n    window.requestAnimationFrame(onAnimationFrame)\n  } else {\n    ticker.tick(0)\n    setTimeout(() => ticker.tick(1), 0)\n    console.log(\n      `@theatre/dataverse is running in a server rather than in a browser. We haven't gotten around to testing server-side rendering, so if something is working in the browser but not on the server, please file a bug: https://github.com/theatre-js/theatre/issues/new`,\n    )\n  }\n\n  return ticker\n}\n\nlet rafTicker: undefined | Ticker\n\n/**\n * The Ticker class helps schedule callbacks. Scheduled callbacks are executed per tick. Ticks can be triggered by an\n * external scheduling strategy, e.g. a raf.\n */\nexport default class Ticker {\n  static get raf(): Ticker {\n    if (!rafTicker) {\n      rafTicker = createRafTicker()\n    }\n    return rafTicker\n  }\n  private _scheduledForThisOrNextTick: Set<ICallback>\n  private _scheduledForNextTick: Set<ICallback>\n  private _timeAtCurrentTick: number\n  private _ticking: boolean = false\n\n  constructor() {\n    this._scheduledForThisOrNextTick = new Set()\n    this._scheduledForNextTick = new Set()\n    this._timeAtCurrentTick = 0\n  }\n\n  /**\n   * Registers for fn to be called either on this tick or the next tick.\n   *\n   * If `onThisOrNextTick()` is called while `Ticker.tick()` is running, the\n   * side effect _will_ be called within the running tick. If you don't want this\n   * behavior, you can use `onNextTick()`.\n   *\n   * Note that `fn` will be added to a `Set()`. Which means, if you call `onThisOrNextTick(fn)`\n   * with the same fn twice in a single tick, it'll only run once.\n   *\n   * @param fn - The function to be registered.\n   *\n   * @see offThisOrNextTick\n   */\n  onThisOrNextTick(fn: ICallback) {\n    this._scheduledForThisOrNextTick.add(fn)\n  }\n\n  /**\n   * Registers a side effect to be called on the next tick.\n   *\n   * @param fn - The function to be registered.\n   *\n   * @see onThisOrNextTick\n   * @see offNextTick\n   */\n  onNextTick(fn: ICallback) {\n    this._scheduledForNextTick.add(fn)\n  }\n\n  /**\n   * De-registers a fn to be called either on this tick or the next tick.\n   *\n   * @param fn - The function to be de-registered.\n   *\n   * @see onThisOrNextTick\n   */\n  offThisOrNextTick(fn: ICallback) {\n    this._scheduledForThisOrNextTick.delete(fn)\n  }\n\n  /**\n   * De-registers a fn to be called on the next tick.\n   *\n   * @param fn - The function to be de-registered.\n   *\n   * @see onNextTick\n   */\n  offNextTick(fn: ICallback) {\n    this._scheduledForNextTick.delete(fn)\n  }\n\n  /**\n   * The time at the start of the current tick if there is a tick in progress, otherwise defaults to\n   * `performance.now()`.\n   */\n  get time() {\n    if (this._ticking) {\n      return this._timeAtCurrentTick\n    } else return performance.now()\n  }\n\n  /**\n   * Triggers a tick which starts executing the callbacks scheduled for this tick.\n   *\n   * @param t - The time at the tick.\n   *\n   * @see onThisOrNextTick\n   * @see onNextTick\n   */\n  tick(t: number = performance.now()) {\n    this._ticking = true\n    this._timeAtCurrentTick = t\n    for (const v of this._scheduledForNextTick) {\n      this._scheduledForThisOrNextTick.add(v)\n    }\n\n    this._scheduledForNextTick.clear()\n    this._tick(0)\n    this._ticking = false\n  }\n\n  private _tick(iterationNumber: number): void {\n    const time = this.time\n\n    if (iterationNumber > 10) {\n      console.warn('_tick() recursing for 10 times')\n    }\n\n    if (iterationNumber > 100) {\n      throw new Error(`Maximum recursion limit for _tick()`)\n    }\n\n    const oldSet = this._scheduledForThisOrNextTick\n    this._scheduledForThisOrNextTick = new Set()\n    for (const fn of oldSet) {\n      fn(time)\n    }\n\n    if (this._scheduledForThisOrNextTick.size > 0) {\n      return this._tick(iterationNumber + 1)\n    }\n  }\n}\n", "import {valueDerivation} from '../Atom'\nimport type {Pointer} from '../pointer'\nimport {isPointer} from '../pointer'\nimport Ticker from '../Ticker'\nimport type {IDerivation} from './IDerivation'\nimport {isDerivation} from './IDerivation'\n\nexport default function* iterateOver<V>(\n  pointerOrDerivation: IDerivation<V> | Pointer<V>,\n): Generator<V, void, void> {\n  let d\n  if (isPointer(pointerOrDerivation)) {\n    d = valueDerivation(pointerOrDerivation) as IDerivation<V>\n  } else if (isDerivation(pointerOrDerivation)) {\n    d = pointerOrDerivation\n  } else {\n    throw new Error(`Only pointers and derivations are supported`)\n  }\n\n  const ticker = new Ticker()\n\n  const untap = d.changes(ticker).tap((v) => {})\n\n  try {\n    while (true) {\n      ticker.tick()\n\n      yield d.getValue()\n    }\n  } finally {\n    untap()\n  }\n}\n", "import Box from '../../Box'\nimport type {$IntentionalAny, VoidFn} from '../../types'\nimport Stack from '../../utils/Stack'\nimport AbstractDerivation from '../AbstractDerivation'\nimport type {IDerivation} from '../IDerivation'\nimport {\n  startIgnoringDependencies,\n  stopIgnoringDependencies,\n  pushCollector,\n  popCollector,\n} from './discoveryMechanism'\n\nconst voidFn = () => {}\n\nexport class PrismDerivation<V> extends AbstractDerivation<V> {\n  protected _cacheOfDendencyValues: Map<IDerivation<unknown>, unknown> =\n    new Map()\n  protected _possiblyStaleDeps = new Set<IDerivation<unknown>>()\n  private _prismScope = new PrismScope()\n\n  constructor(readonly _fn: () => V) {\n    super()\n  }\n\n  _recalculate() {\n    let value: V\n\n    if (this._possiblyStaleDeps.size > 0) {\n      let anActuallyStaleDepWasFound = false\n      startIgnoringDependencies()\n      for (const dep of this._possiblyStaleDeps) {\n        if (this._cacheOfDendencyValues.get(dep) !== dep.getValue()) {\n          anActuallyStaleDepWasFound = true\n          break\n        }\n      }\n      stopIgnoringDependencies()\n      this._possiblyStaleDeps.clear()\n      if (!anActuallyStaleDepWasFound) {\n        // console.log('ok')\n\n        return this._lastValue!\n      }\n    }\n\n    const newDeps: Set<IDerivation<unknown>> = new Set()\n    this._cacheOfDendencyValues.clear()\n\n    const collector = (observedDep: IDerivation<unknown>): void => {\n      newDeps.add(observedDep)\n      this._addDependency(observedDep)\n    }\n\n    pushCollector(collector)\n\n    hookScopeStack.push(this._prismScope)\n    try {\n      value = this._fn()\n    } catch (error) {\n      console.error(error)\n    } finally {\n      const topOfTheStack = hookScopeStack.pop()\n      if (topOfTheStack !== this._prismScope) {\n        console.warn(\n          // @todo guide the user to report the bug in an issue\n          `The Prism hook stack has slipped. This is a bug.`,\n        )\n      }\n    }\n\n    popCollector(collector)\n\n    for (const dep of this._dependencies) {\n      if (!newDeps.has(dep)) {\n        this._removeDependency(dep)\n      }\n    }\n\n    this._dependencies = newDeps\n\n    startIgnoringDependencies()\n    for (const dep of newDeps) {\n      this._cacheOfDendencyValues.set(dep, dep.getValue())\n    }\n    stopIgnoringDependencies()\n\n    return value!\n  }\n\n  _reactToDependencyBecomingStale(msgComingFrom: IDerivation<unknown>) {\n    this._possiblyStaleDeps.add(msgComingFrom)\n  }\n\n  _keepHot() {\n    this._prismScope = new PrismScope()\n    startIgnoringDependencies()\n    this.getValue()\n    stopIgnoringDependencies()\n  }\n\n  _becomeCold() {\n    cleanupScopeStack(this._prismScope)\n    this._prismScope = new PrismScope()\n  }\n}\n\nclass PrismScope {\n  isPrismScope = true\n  private _subs: Record<string, PrismScope> = {}\n\n  sub(key: string) {\n    if (!this._subs[key]) {\n      this._subs[key] = new PrismScope()\n    }\n    return this._subs[key]\n  }\n\n  get subs() {\n    return this._subs\n  }\n}\n\nfunction cleanupScopeStack(scope: PrismScope) {\n  for (const sub of Object.values(scope.subs)) {\n    cleanupScopeStack(sub)\n  }\n  cleanupEffects(scope)\n}\n\nfunction cleanupEffects(scope: PrismScope) {\n  const effects = effectsWeakMap.get(scope)\n  if (effects) {\n    for (const effect of effects.values()) {\n      safelyRun(effect.cleanup, undefined)\n    }\n  }\n  effectsWeakMap.delete(scope)\n}\n\nfunction safelyRun<T, U>(\n  fn: () => T,\n  returnValueInCaseOfError: U,\n): {ok: true; value: T} | {ok: false; value: U} {\n  try {\n    return {value: fn(), ok: true}\n  } catch (error) {\n    // Naming this function can allow the error reporter additional context to the user on where this error came from\n    setTimeout(function PrismReportThrow() {\n      // ensure that the error gets reported, but does not crash the current execution scope\n      throw error\n    })\n    return {value: returnValueInCaseOfError, ok: false}\n  }\n}\n\nconst hookScopeStack = new Stack<PrismScope>()\n\nconst refsWeakMap = new WeakMap<PrismScope, Map<string, IRef<unknown>>>()\n\ntype IRef<T> = {\n  current: T\n}\nconst effectsWeakMap = new WeakMap<PrismScope, Map<string, IEffect>>()\n\ntype IEffect = {\n  deps: undefined | unknown[]\n  cleanup: VoidFn\n}\n\nconst memosWeakMap = new WeakMap<PrismScope, Map<string, IMemo>>()\n\ntype IMemo = {\n  deps: undefined | unknown[] | ReadonlyArray<unknown>\n  cachedValue: unknown\n}\n\nfunction ref<T>(key: string, initialValue: T): IRef<T> {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`prism.ref() is called outside of a prism() call.`)\n  }\n  let refs = refsWeakMap.get(scope)\n  if (refs === undefined) {\n    refs = new Map()\n    refsWeakMap.set(scope, refs)\n  }\n\n  let ref = refs.get(key)\n  if (ref !== undefined) {\n    return ref as $IntentionalAny as IRef<T>\n  } else {\n    const ref = {\n      current: initialValue,\n    }\n    refs.set(key, ref)\n    return ref\n  }\n}\n\n/**\n * An effect hook, similar to React's `useEffect()`, but is not sensitive to call order by using `key`.\n *\n * @param key - the key for the effect. Should be uniqe inside of the prism.\n * @param cb - the callback function. Requires returning a cleanup function.\n * @param deps - the dependency array\n */\nfunction effect(key: string, cb: () => () => void, deps?: unknown[]): void {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`prism.effect() is called outside of a prism() call.`)\n  }\n  let effects = effectsWeakMap.get(scope)\n\n  if (effects === undefined) {\n    effects = new Map()\n    effectsWeakMap.set(scope, effects)\n  }\n\n  let effect = effects.get(key)\n  if (effect === undefined) {\n    effect = {\n      cleanup: voidFn,\n      deps: undefined,\n    }\n    effects.set(key, effect)\n  }\n\n  if (depsHaveChanged(effect.deps, deps)) {\n    effect.cleanup()\n\n    startIgnoringDependencies()\n    effect.cleanup = safelyRun(cb, voidFn).value\n    stopIgnoringDependencies()\n    effect.deps = deps\n  }\n}\n\nfunction depsHaveChanged(\n  oldDeps: undefined | unknown[] | ReadonlyArray<unknown>,\n  newDeps: undefined | unknown[] | ReadonlyArray<unknown>,\n): boolean {\n  if (oldDeps === undefined || newDeps === undefined) {\n    return true\n  }\n\n  const len = oldDeps.length\n  if (len !== newDeps.length) return true\n\n  for (let i = 0; i < len; i++) {\n    if (oldDeps[i] !== newDeps[i]) return true\n  }\n\n  return false\n}\n\n/**\n * Store a value to this {@link prism} stack.\n *\n * Unlike hooks seen in popular frameworks like React, you provide an exact `key` so\n * we can call `prism.memo` in any order, and conditionally.\n *\n * @param deps - Passing in `undefined` will always cause a recompute\n */\nfunction memo<T>(\n  key: string,\n  fn: () => T,\n  deps: undefined | $IntentionalAny[] | ReadonlyArray<$IntentionalAny>,\n): T {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`prism.memo() is called outside of a prism() call.`)\n  }\n\n  let memos = memosWeakMap.get(scope)\n\n  if (!memos) {\n    memos = new Map()\n    memosWeakMap.set(scope, memos)\n  }\n\n  let memo = memos.get(key)\n  if (memo === undefined) {\n    memo = {\n      cachedValue: null,\n      // undefined will always indicate \"deps have changed\", so we set it's initial value as such\n      deps: undefined,\n    }\n    memos.set(key, memo)\n  }\n\n  if (depsHaveChanged(memo.deps, deps)) {\n    startIgnoringDependencies()\n\n    memo.cachedValue = safelyRun(fn, undefined).value\n    stopIgnoringDependencies()\n    memo.deps = deps\n  }\n\n  return memo.cachedValue as $IntentionalAny as T\n}\n\n/**\n * A state hook, similar to react's `useState()`.\n *\n * @param key - the key for the state\n * @param initialValue - the initial value\n * @returns [currentState, setState]\n *\n * @example\n * ```ts\n * import {prism} from 'dataverse'\n *\n * // This derivation holds the current mouse position and updates when the mouse moves\n * const mousePositionD = prism(() => {\n *   const [pos, setPos] = prism.state<[x: number, y: number]>('pos', [0, 0])\n *\n *   prism.effect(\n *     'setupListeners',\n *     () => {\n *       const handleMouseMove = (e: MouseEvent) => {\n *         setPos([e.screenX, e.screenY])\n *       }\n *       document.addEventListener('mousemove', handleMouseMove)\n *\n *       return () => {\n *         document.removeEventListener('mousemove', handleMouseMove)\n *       }\n *     },\n *     [],\n *   )\n *\n *   return pos\n * })\n * ```\n */\nfunction state<T>(key: string, initialValue: T): [T, (val: T) => void] {\n  const {b, setValue} = prism.memo(\n    'state/' + key,\n    () => {\n      const b = new Box<T>(initialValue)\n      const setValue = (val: T) => b.set(val)\n      return {b, setValue}\n    },\n    [],\n  )\n\n  return [b.derivation.getValue(), setValue]\n}\n\n/**\n * This is useful to make sure your code is running inside a `prism()` call.\n *\n * @example\n * ```ts\n * import {prism} from '@theatre/dataverse'\n *\n * function onlyUsefulInAPrism() {\n *   prism.ensurePrism()\n * }\n *\n * prism(() => {\n *   onlyUsefulInAPrism() // will run fine\n * })\n *\n * setTimeout(() => {\n *   onlyUsefulInAPrism() // throws an error\n *   console.log('This will never get logged')\n * }, 0)\n * ```\n */\nfunction ensurePrism(): void {\n  const scope = hookScopeStack.peek()\n  if (!scope) {\n    throw new Error(`The parent function is called outside of a prism() call.`)\n  }\n}\n\nfunction scope<T>(key: string, fn: () => T): T {\n  const parentScope = hookScopeStack.peek()\n  if (!parentScope) {\n    throw new Error(`prism.scope() is called outside of a prism() call.`)\n  }\n  const subScope = parentScope.sub(key)\n  hookScopeStack.push(subScope)\n  const ret = safelyRun(fn, undefined).value\n  hookScopeStack.pop()\n  return ret as $IntentionalAny as T\n}\n\nfunction sub<T>(\n  key: string,\n  fn: () => T,\n  deps: undefined | $IntentionalAny[],\n): T {\n  return memo(key, () => prism(fn), deps).getValue()\n}\n\nfunction inPrism(): boolean {\n  return !!hookScopeStack.peek()\n}\n\ntype IPrismFn = {\n  <T>(fn: () => T): IDerivation<T>\n  ref: typeof ref\n  effect: typeof effect\n  memo: typeof memo\n  ensurePrism: typeof ensurePrism\n  state: typeof state\n  scope: typeof scope\n  sub: typeof sub\n  inPrism: typeof inPrism\n}\n\n/**\n * Creates a derivation from the passed function that adds all derivations referenced\n * in it as dependencies, and reruns the function when these change.\n *\n * @param fn - The function to rerun when the derivations referenced in it change.\n */\nconst prism: IPrismFn = (fn) => {\n  return new PrismDerivation(fn)\n}\n\nprism.ref = ref\nprism.effect = effect\nprism.memo = memo\nprism.ensurePrism = ensurePrism\nprism.state = state\nprism.scope = scope\nprism.sub = sub\nprism.inPrism = inPrism\n\nexport default prism\n", "import type {IdentityDerivationProvider} from './Atom'\nimport type {Pointer} from './pointer'\nimport pointer from './pointer'\nimport type {IBox} from './Box'\nimport Box from './Box'\nimport type {$FixMe, $IntentionalAny} from './types'\nimport {valueDerivation} from './Atom'\n\n/**\n * Allows creating pointer-derivations where the pointer can be switched out.\n *\n * @remarks\n * This allows reacting not just to value changes at a certain pointer, but changes\n * to the proxied pointer too.\n */\nexport default class PointerProxy<O extends {}>\n  implements IdentityDerivationProvider\n{\n  /**\n   * @internal\n   */\n  readonly $$isIdentityDerivationProvider = true\n  private readonly _currentPointerBox: IBox<Pointer<O>>\n  /**\n   * Convenience pointer pointing to the root of this PointerProxy.\n   *\n   * @remarks\n   * Allows convenient use of {@link valueDerivation} and {@link val}.\n   */\n  readonly pointer: Pointer<O>\n\n  constructor(currentPointer: Pointer<O>) {\n    this._currentPointerBox = new Box(currentPointer)\n    this.pointer = pointer({root: this as $FixMe, path: []})\n  }\n\n  /**\n   * Sets the underlying pointer.\n   * @param p - The pointer to be proxied.\n   */\n  setPointer(p: Pointer<O>) {\n    this._currentPointerBox.set(p)\n  }\n\n  /**\n   * Returns a derivation of the value at the provided sub-path of the proxied pointer.\n   *\n   * @param path - The path to create the derivation at.\n   */\n  getIdentityDerivation(path: Array<string | number>) {\n    return this._currentPointerBox.derivation.flatMap((p) => {\n      const subPointer = path.reduce(\n        (pointerSoFar, pathItem) => (pointerSoFar as $IntentionalAny)[pathItem],\n        p,\n      )\n      return valueDerivation(subPointer)\n    })\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
