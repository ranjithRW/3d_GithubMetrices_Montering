import {
  require_react
} from "./chunk-HKFE4NWE.js";
import {
  __commonJS,
  __toESM
} from "./chunk-IGMYUX52.js";

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React = require_react();
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is(x, y2) {
          return x === y2 && (x !== 0 || 1 / x === 1 / y2) || x !== x && y2 !== y2;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useState = React.useState, useEffect2 = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue2 = React.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore2(subscribe2, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
              }
            }
          }
          var value = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value, cachedValue)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState({
            inst: {
              value,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect(function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          }, [subscribe2, value, getSnapshot]);
          useEffect2(function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            };
            return subscribe2(handleStoreChange);
          }, [subscribe2]);
          useDebugValue2(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe2, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM;
        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore2;
        var useSyncExternalStore$2 = React.useSyncExternalStore !== void 0 ? React.useSyncExternalStore : shim;
        exports.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/valtio/esm/index.js
var import_react = __toESM(require_react());

// node_modules/proxy-compare/dist/index.modern.js
var e = Symbol();
var t = Symbol();
var r = Symbol();
var n = Object.getPrototypeOf;
var o = /* @__PURE__ */ new WeakMap();
var s = (e2) => e2 && (o.has(e2) ? o.get(e2) : n(e2) === Object.prototype || n(e2) === Array.prototype);
var c = (e2) => typeof e2 == "object" && e2 !== null;
var i = (n2, o2) => {
  let s2 = false;
  const c2 = (t2, r2, o3) => {
    if (!s2) {
      let s3 = t2.a.get(n2);
      s3 || (s3 = /* @__PURE__ */ new Set(), t2.a.set(n2, s3)), o3 && s3.has(e) || s3.add(r2);
    }
  }, i2 = { f: o2, get(e2, t2) {
    return t2 === r ? n2 : (c2(this, t2), a(e2[t2], this.a, this.c));
  }, has(e2, r2) {
    return r2 === t ? (s2 = true, this.a.delete(n2), true) : (c2(this, r2), r2 in e2);
  }, getOwnPropertyDescriptor(e2, t2) {
    return c2(this, t2, true), Object.getOwnPropertyDescriptor(e2, t2);
  }, ownKeys(t2) {
    return c2(this, e), Reflect.ownKeys(t2);
  } };
  return o2 && (i2.set = i2.deleteProperty = () => false), i2;
};
var a = (e2, t2, o2) => {
  if (!s(e2))
    return e2;
  const c2 = e2[r] || e2, a2 = ((e3) => Object.isFrozen(e3) || Object.values(Object.getOwnPropertyDescriptors(e3)).some((e4) => !e4.writable))(c2);
  let l2 = o2 && o2.get(c2);
  return l2 && l2.f === a2 || (l2 = i(c2, a2), l2.p = new Proxy(a2 ? ((e3) => {
    if (Array.isArray(e3))
      return Array.from(e3);
    const t3 = Object.getOwnPropertyDescriptors(e3);
    return Object.values(t3).forEach((e4) => {
      e4.configurable = true;
    }), Object.create(n(e3), t3);
  })(c2) : c2, l2), o2 && o2.set(c2, l2)), l2.a = t2, l2.c = o2, l2.p;
};
var l = (e2, t2) => {
  const r2 = Reflect.ownKeys(e2), n2 = Reflect.ownKeys(t2);
  return r2.length !== n2.length || r2.some((e3, t3) => e3 !== n2[t3]);
};
var u = (t2, r2, n2, o2) => {
  if (Object.is(t2, r2))
    return false;
  if (!c(t2) || !c(r2))
    return true;
  const s2 = n2.get(t2);
  if (!s2)
    return true;
  if (o2) {
    const e2 = o2.get(t2);
    if (e2 && e2.n === r2)
      return e2.g;
    o2.set(t2, { n: r2, g: false });
  }
  let i2 = null;
  for (const c2 of s2) {
    const s3 = c2 === e ? l(t2, r2) : u(t2[c2], r2[c2], n2, o2);
    if (s3 !== true && s3 !== false || (i2 = s3), i2)
      break;
  }
  return i2 === null && (i2 = true), o2 && o2.set(t2, { n: r2, g: i2 }), i2;
};
var y = (e2) => s(e2) && e2[r] || null;
var p = (e2, t2 = true) => {
  o.set(e2, t2);
};
var g = (e2, t2) => {
  const r2 = [], n2 = /* @__PURE__ */ new WeakSet(), o2 = (e3, s2) => {
    if (n2.has(e3))
      return;
    c(e3) && n2.add(e3);
    const i2 = t2.get(e3);
    i2 ? i2.forEach((t3) => {
      o2(e3[t3], s2 ? [...s2, t3] : [t3]);
    }) : s2 && r2.push(s2);
  };
  return o2(e2), r2;
};

// node_modules/valtio/esm/index.js
var import_shim = __toESM(require_shim());

// node_modules/valtio/esm/vanilla.js
var import_meta = {};
var VERSION = (import_meta.env && import_meta.env.MODE) !== "production" ? Symbol("VERSION") : Symbol();
var LISTENERS = (import_meta.env && import_meta.env.MODE) !== "production" ? Symbol("LISTENERS") : Symbol();
var SNAPSHOT = (import_meta.env && import_meta.env.MODE) !== "production" ? Symbol("SNAPSHOT") : Symbol();
var HANDLER = (import_meta.env && import_meta.env.MODE) !== "production" ? Symbol("HANDLER") : Symbol();
var PROMISE_RESULT = (import_meta.env && import_meta.env.MODE) !== "production" ? Symbol("PROMISE_RESULT") : Symbol();
var PROMISE_ERROR = (import_meta.env && import_meta.env.MODE) !== "production" ? Symbol("PROMISE_ERROR") : Symbol();
var refSet = /* @__PURE__ */ new WeakSet();
function ref(o2) {
  refSet.add(o2);
  return o2;
}
var isObject = (x) => typeof x === "object" && x !== null;
var canProxy = (x) => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer);
var proxyCache = /* @__PURE__ */ new WeakMap();
var globalVersion = 1;
var snapshotCache = /* @__PURE__ */ new WeakMap();
function proxy(initialObject = {}) {
  if (!isObject(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = globalVersion;
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++globalVersion) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  const propListeners = /* @__PURE__ */ new Map();
  const getPropListener = (prop) => {
    let propListener = propListeners.get(prop);
    if (!propListener) {
      propListener = (op, nextVersion) => {
        const newOp = [...op];
        newOp[1] = [prop, ...newOp[1]];
        notifyUpdate(newOp, nextVersion);
      };
      propListeners.set(prop, propListener);
    }
    return propListener;
  };
  const popPropListener = (prop) => {
    const propListener = propListeners.get(prop);
    propListeners.delete(prop);
    return propListener;
  };
  const createSnapshot = (target, receiver) => {
    const cache = snapshotCache.get(receiver);
    if ((cache == null ? void 0 : cache[0]) === version) {
      return cache[1];
    }
    const snapshot2 = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
    p(snapshot2, true);
    snapshotCache.set(receiver, [version, snapshot2]);
    Reflect.ownKeys(target).forEach((key) => {
      const value = Reflect.get(target, key, receiver);
      if (refSet.has(value)) {
        p(value, false);
        snapshot2[key] = value;
      } else if (value instanceof Promise) {
        if (PROMISE_RESULT in value) {
          snapshot2[key] = value[PROMISE_RESULT];
        } else {
          const errorOrPromise = value[PROMISE_ERROR] || value;
          Object.defineProperty(snapshot2, key, {
            get() {
              if (PROMISE_RESULT in value) {
                return value[PROMISE_RESULT];
              }
              throw errorOrPromise;
            }
          });
        }
      } else if (value == null ? void 0 : value[LISTENERS]) {
        snapshot2[key] = value[SNAPSHOT];
      } else {
        snapshot2[key] = value;
      }
    });
    Object.freeze(snapshot2);
    return snapshot2;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    get(target, prop, receiver) {
      if (prop === VERSION) {
        return version;
      }
      if (prop === LISTENERS) {
        return listeners;
      }
      if (prop === SNAPSHOT) {
        return createSnapshot(target, receiver);
      }
      if (prop === HANDLER) {
        return handler;
      }
      return Reflect.get(target, prop, receiver);
    },
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      const childListeners = prevValue == null ? void 0 : prevValue[LISTENERS];
      if (childListeners) {
        childListeners.delete(popPropListener(prop));
      }
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    is: Object.is,
    canProxy,
    set(target, prop, value, receiver) {
      var _a;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && this.is(prevValue, value)) {
        return true;
      }
      const childListeners = prevValue == null ? void 0 : prevValue[LISTENERS];
      if (childListeners) {
        childListeners.delete(popPropListener(prop));
      }
      if (isObject(value)) {
        value = y(value) || value;
      }
      let nextValue;
      if ((_a = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a.set) {
        nextValue = value;
      } else if (value instanceof Promise) {
        nextValue = value.then((v) => {
          nextValue[PROMISE_RESULT] = v;
          notifyUpdate(["resolve", [prop], v]);
          return v;
        }).catch((e2) => {
          nextValue[PROMISE_ERROR] = e2;
          notifyUpdate(["reject", [prop], e2]);
        });
      } else if (value == null ? void 0 : value[LISTENERS]) {
        nextValue = value;
        nextValue[LISTENERS].add(getPropListener(prop));
      } else if (this.canProxy(value)) {
        nextValue = proxy(value);
        nextValue[LISTENERS].add(getPropListener(prop));
      } else {
        nextValue = value;
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = new Proxy(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}
function getVersion(proxyObject) {
  return isObject(proxyObject) ? proxyObject[VERSION] : void 0;
}
function subscribe(proxyObject, callback, notifyInSync) {
  if ((import_meta.env && import_meta.env.MODE) !== "production" && !(proxyObject == null ? void 0 : proxyObject[LISTENERS])) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        callback(ops.splice(0));
      });
    }
  };
  proxyObject[LISTENERS].add(listener);
  return () => {
    proxyObject[LISTENERS].delete(listener);
  };
}
function snapshot(proxyObject) {
  if ((import_meta.env && import_meta.env.MODE) !== "production" && !(proxyObject == null ? void 0 : proxyObject[SNAPSHOT])) {
    console.warn("Please use proxy object");
  }
  return proxyObject[SNAPSHOT];
}
function getHandler(proxyObject) {
  if ((import_meta.env && import_meta.env.MODE) !== "production" && !(proxyObject == null ? void 0 : proxyObject[HANDLER])) {
    console.warn("Please use proxy object");
  }
  return proxyObject[HANDLER];
}

// node_modules/valtio/esm/index.js
var import_meta2 = {};
var { useSyncExternalStore } = import_shim.default;
var useAffectedDebugValue = (state, affected) => {
  const pathList = (0, import_react.useRef)();
  (0, import_react.useEffect)(() => {
    pathList.current = g(state, affected);
  });
  (0, import_react.useDebugValue)(pathList.current);
};
function useSnapshot(proxyObject, options) {
  const notifyInSync = options == null ? void 0 : options.sync;
  const lastSnapshot = (0, import_react.useRef)();
  const lastAffected = (0, import_react.useRef)();
  let inRender = true;
  const currSnapshot = useSyncExternalStore((0, import_react.useCallback)((callback) => {
    const unsub = subscribe(proxyObject, callback, notifyInSync);
    callback();
    return unsub;
  }, [proxyObject, notifyInSync]), () => {
    const nextSnapshot = snapshot(proxyObject);
    try {
      if (!inRender && lastSnapshot.current && lastAffected.current && !u(lastSnapshot.current, nextSnapshot, lastAffected.current, /* @__PURE__ */ new WeakMap())) {
        return lastSnapshot.current;
      }
    } catch (e2) {
    }
    return nextSnapshot;
  }, () => snapshot(proxyObject));
  inRender = false;
  const currAffected = /* @__PURE__ */ new WeakMap();
  (0, import_react.useEffect)(() => {
    lastSnapshot.current = currSnapshot;
    lastAffected.current = currAffected;
  });
  if ((import_meta2.env && import_meta2.env.MODE) !== "production") {
    useAffectedDebugValue(currSnapshot, currAffected);
  }
  const proxyCache2 = (0, import_react.useMemo)(() => /* @__PURE__ */ new WeakMap(), []);
  return a(currSnapshot, currAffected, proxyCache2);
}
export {
  getVersion,
  proxy,
  ref,
  snapshot,
  subscribe,
  getHandler as unstable_getHandler,
  useSnapshot
};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=valtio.js.map
